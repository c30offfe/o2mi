<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Step Grid</title>
  <style>
    html, body { width:100%; height:100%; margin:0; }
    body { background: rgba(0,0,0,0); font-family: system-ui, sans-serif; }
    .panel {
      position: absolute; top: 20px; left: 20px;
      background: rgba(0,0,0,0.65); color: #fff;
      padding: 12px; border-radius: 12px;
      width: 640px;
    }

    .topbar { display:flex; align-items:center; justify-content:space-between; gap:10px; }

    .hint { opacity: 0.85; font-size: 13px; margin-top: 4px; }
    .hintRow { display:flex; align-items:center; justify-content:space-between; gap:12px; }

    .cancelLink { min-width: 90px; text-align: right; font-size: 13px; }
    .cancelLink a {
      color: rgba(255,255,0,0.9);
      text-decoration: none;
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      user-select: none;
    }
    .cancelLink a.show { opacity: 1; pointer-events: auto; }
    .cancelLink a:hover { text-decoration: underline; }

    .creditBar { margin-top: 10px; font-size: 13px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .creditValue { font-weight: 600; color: #8ef7ad; }
    .userLabel { opacity: 0.9; }
    .userValue { font-weight: 600; color: #9dd6ff; }

    .buyRow {
      margin-top: 10px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      min-height: 30px;
      visibility: hidden;
      opacity: 0;
      pointer-events: none;
    }
    .buyRow.show { visibility: visible; opacity: 1; pointer-events: auto; }
    .buyBtn {
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.12);
      color: #aaa;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
    }

    .trackRow { display:flex; align-items:center; gap:10px; margin-top:10px; }
    .trackName { width: 70px; opacity: .9; font-size: 13px; }
    .grid { display:grid; grid-template-columns: repeat(16, 1fr); gap:6px; width: 100%; }

    .step {
      height: 22px; border-radius: 6px; cursor: pointer;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.18);
      user-select: none;
    }
    .step.on { background: rgba(0,255,120,0.55); border-color: rgba(0,255,120,0.9); }
    .step.play { outline: 1px solid rgba(255,255,255,0.18); }
    .step.pending { outline: 2px solid rgba(255,255,0,0.9); }

    .small { opacity: 0.75; font-size: 12px; margin-top: 10px; }
    .devDebugWrap { margin-top: 10px; display: none; }
    .devDebugWrap.show { display: block; }
    .devDebugToggle {
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.12);
      color: #cfe8ff;
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 11px;
      cursor: pointer;
    }
    .devDebug {
      margin-top: 10px;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.25);
      color: #cfe8ff;
      font-size: 11px;
      line-height: 1.35;
      white-space: pre-wrap;
      word-break: break-word;
      display: none;
    }
    .devDebug.show { display: block; }
  </style>
</head>

<body>
<div class="panel">
  <div class="topbar">
    <div id="status">Overlay geladen…</div>
  </div>

  <div class="hintRow">
    <div class="hint" id="hint">Init…</div>
    <div class="cancelLink"><a id="cancelLink">Abbrechen</a></div>
  </div>

  <div class="creditBar">
    Credits: <span id="creditValue" class="creditValue">-</span>
    <span>•</span>
    <span id="userIdentityLabel" class="userLabel">User:</span>
    <span id="userIdentityValue" class="userValue">-</span>
  </div>
  <div id="buyRow" class="buyRow">
    <button class="buyBtn" data-sku="credits_100">1000 Bits = 100 Credits</button>
    <button class="buyBtn" data-sku="credits_250">2000 Bits = 250 Credits</button>
    <button class="buyBtn" data-sku="credits_400">3000 Bits = 400 Credits</button>
  </div>

  <div id="tracks"></div>
  <div class="small" id="debug"></div>
  <div id="devDebugWrap" class="devDebugWrap">
    <button id="devDebugToggle" type="button" class="devDebugToggle">DEV Debug aufklappen</button>
    <pre id="devDebugBox" class="devDebug"></pre>
  </div>
</div>

<script defer src="https://extension-files.twitch.tv/helper/v1/twitch-ext.min.js"></script>

<script defer>
  // --- Grid / Voices ---
  const STEPS = 16;

  // Diese Pitches sind "Ableton-ready" (v2 voices):
  const VOICES = [
    { name: "Kick", pitch: 36, velocity: 110, gate: 0.20 },
    { name: "Snare", pitch: 38, velocity:  95, gate: 0.20 },
    { name: "Hat",  pitch: 42, velocity:  75, gate: 0.15 },
    { name: "Bass", pitch: 48, velocity: 100, gate: 0.25 },
  ];

  // --- Backend ---
  const EBS_BASE = "https://o2mi.far-future.com";

  // Credits
  const COST_PER_TOGGLE = 1;
  const CREDIT_SKUS = {
    credits_100: { bits: 1000, credits: 100 },
    credits_250: { bits: 2000, credits: 250 },
    credits_400: { bits: 3000, credits: 400 },
  };

  // --- UI handles ---
  const tracksEl = document.getElementById("tracks");
  const statusEl = document.getElementById("status");
  const hintEl   = document.getElementById("hint");
  const debugEl  = document.getElementById("debug");
  const cancelLink = document.getElementById("cancelLink");
  const creditValueEl = document.getElementById("creditValue");
  const userIdentityLabelEl = document.getElementById("userIdentityLabel");
  const userIdentityValueEl = document.getElementById("userIdentityValue");
  const buyRowEl = document.getElementById("buyRow");
  const devDebugWrapEl = document.getElementById("devDebugWrap");
  const devDebugToggleEl = document.getElementById("devDebugToggle");
  const devDebugBoxEl = document.getElementById("devDebugBox");

  // --- Runtime state ---
  let authState = null;
  let runtimeEnv = "unknown";
  let isDevMode = false;

  let credits = 0;
  let pendingToggle = null;
  let pendingPurchaseSku = null;

  let technicalUserId = "";
  let userName = "";
  let displayName = "";
  let lastAuthSnapshot = null;
  let devDebugOpen = false;

  // Authoritative state from server:
  // we store as boolean grid for UI, but it's derived from server pattern payload
  const state = VOICES.map(() => new Array(STEPS).fill(false));
  let lastPattern = null; // the v2 JSON payload we got (for debug)
  let lastRev = null;

  // WS
  let ws = null;
  let wsConnected = false;
  let wsReconnectTimer = null;

  // Playhead (UI only)
  let playStep = 0;
  const bpm = 90;
  const stepMs = (60_000 / bpm) / 4;

  // DOM cache
  const stepEls = VOICES.map(() => new Array(STEPS));

  function renderCredits() {
    creditValueEl.textContent = String(credits);
  }

  function showBuyOptions(show) {
    buyRowEl.classList.toggle("show", !!show);
  }

  function maskToken(v) {
    if (!v || typeof v !== "string") return "-";
    if (v.length <= 14) return `${v.slice(0, 4)}...`;
    return `${v.slice(0, 8)}...${v.slice(-4)}`;
  }

  function getApiUserId() {
    return technicalUserId || "";
  }

  // --- Mask decode (HEX only in this overlay start; server supports HEX + b64) ---
  // MSB-first mapping per nibble: 8,4,2,1
  function hexMaskToBools(maskHex, steps) {
    const m = String(maskHex || "").replace(/^"|"$/g, "");
    const out = new Array(steps).fill(false);
    for (let i = 0; i < steps; i++) {
      const nibbleIndex = Math.floor(i / 4);
      const bitIndex = i % 4;
      const ch = m.charAt(nibbleIndex);
      const nibble = parseInt(ch, 16);
      if (Number.isNaN(nibble)) continue;
      const bitMask = (8 >> bitIndex);
      out[i] = (nibble & bitMask) !== 0;
    }
    return out;
  }

  function patternStringForTrack(t) {
    return state[t].map(x => x ? "1" : "0").join("");
  }

  function updateDebug() {
    const masks = (lastPattern?.voices || []).map(v => `${v.pitch}:${v.mask}`).join(" | ");
    debugEl.textContent =
        VOICES.map((v,t)=> `${v.name}: ${patternStringForTrack(t)}`).join("   |   ")
        + (masks ? `\nmask: ${masks}` : "")
        + (lastRev !== null ? `\nrev: ${lastRev}` : "");
  }

  function renderDevDebug() {
    if (!isDevMode) {
      devDebugWrapEl.classList.remove("show");
      devDebugToggleEl.textContent = "DEV Debug aufklappen";
      devDebugBoxEl.classList.remove("show");
      devDebugBoxEl.textContent = "";
      return;
    }
    devDebugWrapEl.classList.add("show");

    const viewer = globalThis.Twitch?.ext?.viewer || {};
    const auth = lastAuthSnapshot || {};
    const rawViewerId = String(viewer.id || "");
    const rawAuthUserId = String(auth.userId || "");
    const authUserIdNumeric = /^\d{1,32}$/.test(rawAuthUserId)
        ? rawAuthUserId
        : (rawAuthUserId.match(/^U(\d{1,32})$/)?.[1] || null);

    const payload = {
      env: runtimeEnv,
      ws: { connected: wsConnected, rev: lastRev },
      identity: {
        apiUserId: getApiUserId() || null,
        technicalUserId: technicalUserId || null,
        userName: userName || null,
        displayName: displayName || null,
      },
      auth: {
        channelId: auth.channelId || null,
        clientId: auth.clientId || null,
        rawUserId: auth.userId || null,
        normalizedNumericUserId: authUserIdNumeric,
        role: auth.role || null,
        opaqueUserId: auth.userId && !/^\d{1,32}$/.test(String(auth.userId)) ? auth.userId : null,
        helixTokenMasked: maskToken(auth.helixToken),
        tokenMasked: maskToken(auth.token),
      },
      viewer: {
        rawId: viewer.id || null,
        normalizedNumericId: /^\d{1,32}$/.test(rawViewerId) ? rawViewerId : null,
        role: viewer.role || null,
        isLinked: viewer.isLinked ?? null,
        opaqueId: viewer.opaqueId || null,
        sessionToken: viewer.sessionToken ? "[present]" : null,
      },
      lastPattern: lastPattern || null,
    };

    devDebugBoxEl.textContent = `DEV DEBUG\n${JSON.stringify(payload, null, 2)}`;
    devDebugToggleEl.textContent = devDebugOpen ? "DEV Debug zuklappen" : "DEV Debug aufklappen";
    devDebugBoxEl.classList.toggle("show", devDebugOpen);
  }

  async function detectMode() {
    try {
      const r = await fetch(`${EBS_BASE}/health`);
      if (!r.ok) return;
      const body = await r.json();
      runtimeEnv = String(body.env || "unknown").toLowerCase();
      isDevMode = runtimeEnv === "development" || runtimeEnv === "dev";
    } catch (_) {
      // Keep safe default (non-dev display).
      // TODO: At least: console.log(`Exception while doing something: ${err}`);
    }
  }

  function updateIdentityFromTwitch() {
    const viewer = globalThis.Twitch?.ext?.viewer || {};
    const viewerId = String(viewer.id || "");
    const authUserId = String(authState?.userId || "");
    const broadcasterIdMatch = authUserId.match(/^U(\d{1,32})$/);

    // Use only numeric Twitch IDs as technical IDs. auth.userId can be opaque.
    // TODO: Testen und prüfen, was hier passiert, wenn U12...34 oder nur 12...34 kommt - Code = robust?
    if (/^\d{1,32}$/.test(viewerId)) {
      technicalUserId = viewerId;
    } else if (/^\d{1,32}$/.test(authUserId)) {
      technicalUserId = authUserId;
    } else if (broadcasterIdMatch) {
      technicalUserId = broadcasterIdMatch[1];
    } else {
      technicalUserId = "";
    }

    userName = "";
    displayName = "";
  }

  async function fetchIdentityFromHelix() {
    if (!technicalUserId || !authState?.helixToken || !authState?.clientId) return;

    try {
      const r = await fetch(`https://api.twitch.tv/helix/users?id=${encodeURIComponent(technicalUserId)}`, {
        headers: {
          "Client-Id": authState.clientId,
          "Authorization": `Extension ${authState.helixToken}`,
        },
      });
      if (!r.ok) return;
      const body = await r.json();
      const u = body?.data?.[0];
      if (!u) return;
      userName = u.login || "";
      displayName = u.display_name || "";
    } catch (_) {
      // Ignore identity lookup errors for UI only.
    }
  }

  function renderIdentity() {
    if (isDevMode) {
      userIdentityLabelEl.textContent = "DEV:";
      userIdentityValueEl.textContent = `userId=${technicalUserId || "-"} | userName=${userName || "-"}`;
      renderDevDebug();
      return;
    }

    userIdentityLabelEl.textContent = "User:";
    userIdentityValueEl.textContent = displayName || "-";
    renderDevDebug();
  }

  function buildUIOnce() {
    tracksEl.innerHTML = "";
    for (let t = 0; t < VOICES.length; t++) {
      const row = document.createElement("div");
      row.className = "trackRow";

      const name = document.createElement("div");
      name.className = "trackName";
      name.textContent = VOICES[t].name;

      const grid = document.createElement("div");
      grid.className = "grid";

      for (let i = 0; i < STEPS; i++) {
        const b = document.createElement("div");
        b.className = "step";
        b.title = `${VOICES[t].name} — Step ${i + 1}`;
        b.addEventListener("click", () => onStepClick(t, i));
        grid.appendChild(b);
        stepEls[t][i] = b;
      }

      row.appendChild(name);
      row.appendChild(grid);
      tracksEl.appendChild(row);
    }
  }

  function refreshClasses() {
    for (let t = 0; t < VOICES.length; t++) {
      for (let i = 0; i < STEPS; i++) {
        const el = stepEls[t][i];
        el.classList.toggle("on", state[t][i]);
        el.classList.toggle("play", i === playStep);
        el.classList.toggle("pending", pendingToggle && pendingToggle.t === t && pendingToggle.i === i);
      }
    }
    cancelLink.classList.toggle("show", !!pendingToggle);
  }

  function cancelPending(reason) {
    pendingToggle = null;
    showBuyOptions(false);
    refreshClasses();
    if (reason) hintEl.textContent = reason;
  }

  cancelLink.addEventListener("click", () => cancelPending("Abgebrochen ✅"));
  devDebugToggleEl.addEventListener("click", () => { devDebugOpen = !devDebugOpen; renderDevDebug(); });

  async function fetchBalance() {
    if (!authState?.channelId || !getApiUserId()) return;
    const qs = new URLSearchParams({ channelId: authState.channelId, userId: getApiUserId() });
    const r = await fetch(`${EBS_BASE}/balance?${qs.toString()}`);
    if (!r.ok) throw new Error(`/balance ${r.status}`);
    const body = await r.json();
    credits = Number(body.credits || 0);
    renderCredits();
  }

  function applyPatternFromServer(pattern, rev) {
    // pattern is v2 payload
    lastPattern = pattern;
    lastRev = rev ?? lastRev;

    const steps = Number(pattern?.steps || STEPS);
    // overlay is fixed 16 right now; if server sends !=16, we still display first 16 safely
    const voices = Array.isArray(pattern?.voices) ? pattern.voices : [];

    for (let t = 0; t < VOICES.length; t++) {
      const vPitch = VOICES[t].pitch;
      const voice = voices.find(x => Number(x.pitch) === vPitch) || voices[t];

      const mask = voice?.mask || "0000";
      const bools = hexMaskToBools(mask, STEPS); // using 16 steps start
      for (let i = 0; i < STEPS; i++) state[t][i] = !!bools[i];
    }

    refreshClasses();
    updateDebug();
    renderDevDebug();
  }

  // --- WebSocket ---
  function wsUrl() {
    // https://... -> wss://..., http://... -> ws://...
    if (EBS_BASE.startsWith("https://")) return "wss://" + EBS_BASE.slice("https://".length) + "/ws";
    if (EBS_BASE.startsWith("http://")) return "ws://" + EBS_BASE.slice("http://".length) + "/ws";
    return EBS_BASE + "/ws";
  }

  function connectWs() {
    if (!authState?.channelId) return;
    if (ws) { try { ws.close(); } catch (_) {} ws = null; }

    const url = wsUrl();
    ws = new WebSocket(url);

    ws.onopen = () => {
      wsConnected = true;
      statusEl.textContent = `Overlay läuft ✅ (WS verbunden) — channelId=${authState.channelId}`;
      hintEl.textContent = "Live Sync aktiv ✅";
      renderDevDebug();

      ws.send(JSON.stringify({
        type: "hello",
        client: "overlay",
        channelId: authState.channelId,
        patternKey: "main",
        userId: getApiUserId() || null
      }));
    };

    ws.onclose = () => {
      wsConnected = false;
      renderDevDebug();
      statusEl.textContent = `Overlay läuft ✅ (WS getrennt) — channelId=${authState.channelId}`;
      hintEl.textContent = "Sync getrennt… reconnect…";
      scheduleReconnect();
    };

    ws.onerror = () => {
      // onclose handles reconnect
    };

    ws.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(String(ev.data || "{}")); } catch (_) { return; }
      if (!msg || typeof msg !== "object") return;

      if (msg.type === "snapshot") {
        applyPatternFromServer(msg.payload, msg.rev);
        return;
      }
      if (msg.type === "pattern_update") {
        applyPatternFromServer(msg.payload, msg.rev);
        return;
      }
    };
  }

  function scheduleReconnect() {
    if (wsReconnectTimer) return;
    wsReconnectTimer = setTimeout(() => {
      wsReconnectTimer = null;
      connectWs();
    }, 1500);
  }

  // --- Toggle: server authoritative (charges credits + updates pattern) ---
  async function toggleOnServer(t, i) {
    const r = await fetch(`${EBS_BASE}/pattern/toggle`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        channelId: authState.channelId,
        userId: getApiUserId(),
        voiceIndex: t,
        stepIndex: i,
        cost: COST_PER_TOGGLE,
      }),
    });

    const body = await r.json().catch(() => ({}));

    if (r.ok) {
      credits = Number(body.credits || credits);
      renderCredits();
      // Apply immediately (WS should also deliver it, but this makes UI snappy)
      if (body.pattern) applyPatternFromServer(body.pattern, body.rev);
      return { ok: true };
    }

    if (r.status === 402) {
      credits = Number(body.credits || 0);
      renderCredits();
      return { ok: false, insufficient: true };
    }

    throw new Error(body.error || `/pattern/toggle ${r.status}`);
  }

  async function onStepClick(t, i) {
    if (!authState?.channelId || !getApiUserId()) {
      hintEl.textContent = "Noch nicht autorisiert";
      return;
    }
    if (pendingToggle) {
      hintEl.textContent = "Warte… oder klicke Abbrechen";
      return;
    }

    pendingToggle = { t, i };
    refreshClasses();

    try {
      const res = await toggleOnServer(t, i);
      if (res.ok) {
        pendingToggle = null;
        refreshClasses();
        hintEl.textContent = `Step gesetzt ✅ (${credits} Credits übrig)`;
        return;
      }

      showBuyOptions(true);
      hintEl.textContent = "Keine Credits mehr. Bitte Credit-Paket kaufen.";
    } catch (e) {
      cancelPending();
      hintEl.textContent = `Fehler: ${String(e)}`;
    }
  }

  // Purchase stays mostly the same
  async function grantPurchasedCredits(sku) {
    const r = await fetch(`${EBS_BASE}/purchase`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ channelId: authState.channelId, userId: getApiUserId(), sku }),
    });
    const body = await r.json();
    if (!r.ok) throw new Error(body.error || `/purchase ${r.status}`);
    credits = Number(body.credits || 0);
    renderCredits();
  }

  function startPurchase(sku) {
    if (!pendingToggle) {
      hintEl.textContent = "Bitte zuerst einen Step klicken.";
      return;
    }
    if (!globalThis.Twitch?.ext?.bits?.useBits) {
      hintEl.textContent = "Bits API nicht verfügbar";
      return;
    }

    pendingPurchaseSku = sku;
    const pkg = CREDIT_SKUS[sku];
    hintEl.textContent = `Kaufdialog: ${pkg.bits} Bits für ${pkg.credits} Credits…`;
    Twitch.ext.bits.useBits(sku);
  }

  document.querySelectorAll(".buyBtn").forEach((btn) => {
    btn.addEventListener("click", () => startPurchase(btn.dataset.sku));
  });

  if (globalThis.Twitch?.ext?.bits?.onTransactionComplete) {
    Twitch.ext.bits.onTransactionComplete(async (tx) => {
      const sku = tx?.product?.sku;
      if (!sku || !CREDIT_SKUS[sku] || sku !== pendingPurchaseSku) {
        hintEl.textContent = "Transaktion ignoriert (anderes Produkt).";
        return;
      }

      try {
        await grantPurchasedCredits(sku);
        showBuyOptions(false);

        if (pendingToggle) {
          const { t, i } = pendingToggle;
          const res = await toggleOnServer(t, i);
          if (res.ok) {
            pendingToggle = null;
            refreshClasses();
            hintEl.textContent = `Kauf OK ✅ + Step gesetzt (${credits} Credits übrig)`;
          } else {
            hintEl.textContent = "Credits gekauft, aber Step konnte nicht gesetzt werden.";
          }
        }
      } catch (e) {
        hintEl.textContent = `Fehler nach Kauf: ${String(e)}`;
      } finally {
        pendingPurchaseSku = null;
      }
    });
  }

  // --- Init UI ---
  buildUIOnce();
  updateDebug();
  renderCredits();
  refreshClasses();

  setInterval(() => {
    playStep = (playStep + 1) % STEPS;
    refreshClasses();
  }, stepMs);

  // Twitch init
  globalThis.addEventListener("DOMContentLoaded", () => {
    Twitch.ext.onAuthorized(async (auth) => {
      authState = auth;
      lastAuthSnapshot = {
        channelId: auth.channelId,
        clientId: auth.clientId,
        userId: auth.userId,
        role: auth.role,
        helixToken: auth.helixToken,
        token: auth.token,
      };

      updateIdentityFromTwitch();
      statusEl.textContent = `Overlay läuft ✅ (authorized) — channelId=${auth.channelId}`;

      await detectMode();
      await fetchIdentityFromHelix();
      renderIdentity();

      try {
        await fetchBalance();
        hintEl.textContent = "Klick auf Step kostet 1 Credit";
      } catch (e) {
        hintEl.textContent = `Konnte Credits nicht laden: ${String(e)}`;
      }

      // Connect WS last (so userId/channelId ready)
      connectWs();
    });
  });
</script>
</body>
</html>
