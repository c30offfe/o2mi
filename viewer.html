<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Step Grid</title>
  <style>
    html, body { width:100%; height:100%; margin:0; }
    body { background: rgba(0,0,0,0); font-family: system-ui, sans-serif; }
    .panel {
      position: absolute; top: 20px; left: 20px;
      background: rgba(0,0,0,0.65); color: #fff;
      padding: 12px; border-radius: 12px;
      width: 640px;
    }

    .topbar { display:flex; align-items:center; justify-content:space-between; gap:10px; }

    .hint { opacity: 0.85; font-size: 13px; margin-top: 4px; }
    .hintRow { display:flex; align-items:center; justify-content:space-between; gap:12px; }

    .cancelLink { min-width: 90px; text-align: right; font-size: 13px; }
    .cancelLink a {
      color: rgba(255,255,0,0.9);
      text-decoration: none;
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      user-select: none;
    }
    .cancelLink a.show { opacity: 1; pointer-events: auto; }
    .cancelLink a:hover { text-decoration: underline; }

    .creditBar { margin-top: 10px; font-size: 13px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .creditValue { font-weight: 600; color: #8ef7ad; }
    .userLabel { opacity: 0.9; }
    .userValue { font-weight: 600; color: #9dd6ff; }

    .buyRow {
      margin-top: 10px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      min-height: 30px;
      visibility: hidden;
      opacity: 0;
      pointer-events: none;
    }
    .buyRow.show { visibility: visible; opacity: 1; pointer-events: auto; }
    .buyBtn {
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.12);
      color: #aaa;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
    }

    .trackRow { display:flex; align-items:center; gap:10px; margin-top:10px; }
    .trackName { width: 70px; opacity: .9; font-size: 13px; }
    .grid { display:grid; grid-template-columns: repeat(16, 1fr); gap:6px; width: 100%; }

    .step {
      height: 22px; border-radius: 6px; cursor: pointer;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.18);
      user-select: none;
    }
    .step.on { background: rgba(0,255,120,0.55); border-color: rgba(0,255,120,0.9); }
    .step.play { outline: 1px solid rgba(255,255,255,0.18); }
    .step.pending { outline: 2px solid rgba(255,255,0,0.9); }

    .small { opacity: 0.75; font-size: 12px; margin-top: 10px; }
    .devDebugWrap {
      margin-top: 10px;
      display: none;
    }
    .devDebugWrap.show { display: block; }
    .devDebugToggle {
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.12);
      color: #cfe8ff;
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 11px;
      cursor: pointer;
    }
    .devDebug {
      margin-top: 10px;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.25);
      color: #cfe8ff;
      font-size: 11px;
      line-height: 1.35;
      white-space: pre-wrap;
      word-break: break-word;
      display: none;
    }
    .devDebug.show { display: block; }
  </style>
</head>

<body>
<div class="panel">
  <div class="topbar">
    <div id="status">Overlay geladen…</div>
  </div>

  <div class="hintRow">
    <div class="hint" id="hint">Init…</div>
    <div class="cancelLink"><a id="cancelLink">Abbrechen</a></div>
  </div>

  <div class="creditBar">
    Credits: <span id="creditValue" class="creditValue">-</span>
    <span>•</span>
    <span id="userIdentityLabel" class="userLabel">User:</span>
    <span id="userIdentityValue" class="userValue">-</span>
  </div>
  <div id="buyRow" class="buyRow">
    <button class="buyBtn" data-sku="credits_100">1000 Bits = 100 Credits</button>
    <button class="buyBtn" data-sku="credits_250">2000 Bits = 250 Credits</button>
    <button class="buyBtn" data-sku="credits_400">3000 Bits = 400 Credits</button>
  </div>

  <div id="tracks"></div>
  <div class="small" id="debug"></div>
  <div id="devDebugWrap" class="devDebugWrap">
    <button id="devDebugToggle" type="button" class="devDebugToggle">DEV Debug aufklappen</button>
    <pre id="devDebugBox" class="devDebug"></pre>
  </div>
</div>

<script defer src="https://extension-files.twitch.tv/helper/v1/twitch-ext.min.js"></script>

<script defer>
  const STEPS = 16;
  const trackNames = ["Kick", "Snare", "Hat", "Bass"];
  const state = trackNames.map(() => new Array(STEPS).fill(false));

  const EBS_BASE = "https://o2mi.far-future.com";
  const COST_PER_TOGGLE = 1;
  const CREDIT_SKUS = {
    credits_100: { bits: 1000, credits: 100 },
    credits_250: { bits: 2000, credits: 250 },
    credits_400: { bits: 3000, credits: 400 },
  };

  const tracksEl = document.getElementById("tracks");
  const statusEl = document.getElementById("status");
  const hintEl   = document.getElementById("hint");
  const debugEl  = document.getElementById("debug");
  const cancelLink = document.getElementById("cancelLink");
  const creditValueEl = document.getElementById("creditValue");
  const userIdentityLabelEl = document.getElementById("userIdentityLabel");
  const userIdentityValueEl = document.getElementById("userIdentityValue");
  const buyRowEl = document.getElementById("buyRow");
  const devDebugWrapEl = document.getElementById("devDebugWrap");
  const devDebugToggleEl = document.getElementById("devDebugToggle");
  const devDebugBoxEl = document.getElementById("devDebugBox");

  let authState = null;
  let runtimeEnv = "unknown";
  let isDevMode = false;
  let credits = 0;
  let pendingToggle = null;
  let pendingPurchaseSku = null;
  let technicalUserId = "";
  let userName = "";
  let displayName = "";
  let lastAuthSnapshot = null;
  let devDebugOpen = false;

  let playStep = 0;
  const bpm = 90;
  const stepMs = (60_000 / bpm) / 4;

  const stepEls = trackNames.map(() => new Array(STEPS));

  function patternStringForTrack(t) {
    return state[t].map(x => x ? "1" : "0").join("");
  }

  function updateDebug() {
    debugEl.textContent = trackNames.map((n,t)=> `${n}: ${patternStringForTrack(t)}`).join("   |   ");
  }

  function renderCredits() {
    creditValueEl.textContent = String(credits);
  }

  function maskToken(v) {
    if (!v || typeof v !== "string") return "-";
    if (v.length <= 14) return `${v.slice(0, 4)}...`;
    return `${v.slice(0, 8)}...${v.slice(-4)}`;
  }

  function renderDevDebug() {
    if (!isDevMode) {
      devDebugWrapEl.classList.remove("show");
      devDebugToggleEl.textContent = "DEV Debug aufklappen";
      devDebugBoxEl.classList.remove("show");
      devDebugBoxEl.textContent = "";
      return;
    }
    devDebugWrapEl.classList.add("show");

    const viewer = globalThis.Twitch?.ext?.viewer || {};
    const auth = lastAuthSnapshot || {};
    const rawViewerId = String(viewer.id || "");
    const rawAuthUserId = String(auth.userId || "");
    const authUserIdNumeric = /^[0-9]{1,32}$/.test(rawAuthUserId)
      ? rawAuthUserId
      : (rawAuthUserId.match(/^U([0-9]{1,32})$/)?.[1] || null);
    const payload = {
      env: runtimeEnv,
      identity: {
        apiUserId: getApiUserId() || null,
        technicalUserId: technicalUserId || null,
        userName: userName || null,
        displayName: displayName || null,
      },
      auth: {
        channelId: auth.channelId || null,
        clientId: auth.clientId || null,
        rawUserId: auth.userId || null,
        normalizedNumericUserId: authUserIdNumeric,
        role: auth.role || null,
        opaqueUserId: auth.userId && !/^[0-9]{1,32}$/.test(String(auth.userId)) ? auth.userId : null,
        helixTokenMasked: maskToken(auth.helixToken),
        tokenMasked: maskToken(auth.token),
      },
      viewer: {
        rawId: viewer.id || null,
        normalizedNumericId: /^[0-9]{1,32}$/.test(rawViewerId) ? rawViewerId : null,
        role: viewer.role || null,
        isLinked: viewer.isLinked ?? null,
        opaqueId: viewer.opaqueId || null,
        sessionToken: viewer.sessionToken ? "[present]" : null,
      },
    };

    devDebugBoxEl.textContent = `DEV DEBUG\n${JSON.stringify(payload, null, 2)}`;
    devDebugToggleEl.textContent = devDebugOpen ? "DEV Debug zuklappen" : "DEV Debug aufklappen";
    devDebugBoxEl.classList.toggle("show", devDebugOpen);
  }

  async function detectMode() {
    try {
      const r = await fetch(`${EBS_BASE}/health`);
      if (!r.ok) return;
      const body = await r.json();
      runtimeEnv = String(body.env || "unknown").toLowerCase();
      isDevMode = runtimeEnv === "development" || runtimeEnv === "dev";
    } catch (_) {
      // Keep safe default (non-dev display).
      // TODO: At least: console.log(`Exception while doing something: ${err}`);
    }
  }

  function updateIdentityFromTwitch() {
    const viewer = globalThis.Twitch?.ext?.viewer || {};
    const viewerId = String(viewer.id || "");
    const authUserId = String(authState?.userId || "");
    const broadcasterIdMatch = authUserId.match(/^U([0-9]{1,32})$/);

    // Use only numeric Twitch IDs as technical IDs. auth.userId can be opaque.
    // TODO: Testen und prüfen, was hier passiert, wenn U12...34 oder nur 12...34 kommt - Code = robust?
    if (/^[0-9]{1,32}$/.test(viewerId)) {
      technicalUserId = viewerId;
    } else if (/^[0-9]{1,32}$/.test(authUserId)) {
      technicalUserId = authUserId;
    } else if (broadcasterIdMatch) {
      technicalUserId = broadcasterIdMatch[1];
    } else {
      technicalUserId = "";
    }

    userName = "";
    displayName = "";
  }

  async function fetchIdentityFromHelix() {
    if (!technicalUserId || !authState?.helixToken || !authState?.clientId) return;

    try {
      const r = await fetch(`https://api.twitch.tv/helix/users?id=${encodeURIComponent(technicalUserId)}`, {
        headers: {
          "Client-Id": authState.clientId,
          "Authorization": `Extension ${authState.helixToken}`,
        },
      });
      if (!r.ok) return;
      const body = await r.json();
      const u = body?.data?.[0];
      if (!u) return;
      userName = u.login || "";
      displayName = u.display_name || "";
    } catch (_) {
      // Ignore identity lookup errors for UI only.
    }
  }

  function renderIdentity() {
    if (isDevMode) {
      userIdentityLabelEl.textContent = "DEV:";
      userIdentityValueEl.textContent = `userId=${technicalUserId || "-"} | userName=${userName || "-"}`;
      renderDevDebug();
      return;
    }

    userIdentityLabelEl.textContent = "User:";
    userIdentityValueEl.textContent = displayName || "-";
    renderDevDebug();
  }

  function getApiUserId() {
    return technicalUserId || "";
  }

  function showBuyOptions(show) {
    buyRowEl.classList.toggle("show", !!show);
  }

  function buildUIOnce() {
    tracksEl.innerHTML = "";
    for (let t = 0; t < trackNames.length; t++) {
      const row = document.createElement("div");
      row.className = "trackRow";

      const name = document.createElement("div");
      name.className = "trackName";
      name.textContent = trackNames[t];

      const grid = document.createElement("div");
      grid.className = "grid";

      for (let i = 0; i < STEPS; i++) {
        const b = document.createElement("div");
        b.className = "step";
        b.title = `${trackNames[t]} — Step ${i + 1}`;
        b.addEventListener("click", () => onStepClick(t, i));
        grid.appendChild(b);
        stepEls[t][i] = b;
      }

      row.appendChild(name);
      row.appendChild(grid);
      tracksEl.appendChild(row);
    }
  }

  function refreshClasses() {
    for (let t = 0; t < trackNames.length; t++) {
      for (let i = 0; i < STEPS; i++) {
        const el = stepEls[t][i];
        el.classList.toggle("on", state[t][i]);
        el.classList.toggle("play", i === playStep);
        el.classList.toggle("pending", pendingToggle && pendingToggle.t === t && pendingToggle.i === i);
      }
    }
    cancelLink.classList.toggle("show", !!pendingToggle);
  }

  function applyToggle(t, i) {
    state[t][i] = !state[t][i];
    refreshClasses();
    updateDebug();
  }

  function cancelPending(reason) {
    pendingToggle = null;
    showBuyOptions(false);
    refreshClasses();
    if (reason) {
      hintEl.textContent = reason;
    }
  }

  cancelLink.addEventListener("click", () => {
    cancelPending("Abgebrochen ✅");
  });
  devDebugToggleEl.addEventListener("click", () => {
    devDebugOpen = !devDebugOpen;
    renderDevDebug();
  });

  async function fetchBalance() {
    if (!authState?.channelId || !getApiUserId()) return;

    const qs = new URLSearchParams({ channelId: authState.channelId, userId: getApiUserId() });
    const r = await fetch(`${EBS_BASE}/balance?${qs.toString()}`);
    if (!r.ok) throw new Error(`/balance ${r.status}`);
    const body = await r.json();
    credits = Number(body.credits || 0);
    renderCredits();
  }

  async function consumeCredit() {
    const r = await fetch(`${EBS_BASE}/use`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        channelId: authState.channelId,
        userId: getApiUserId(),
        cost: COST_PER_TOGGLE,
      }),
    });

    const body = await r.json();
    if (r.ok) {
      credits = Number(body.credits || 0);
      renderCredits();
      return { ok: true };
    }

    if (r.status === 402) {
      credits = Number(body.credits || 0);
      renderCredits();
      return { ok: false, insufficient: true };
    }

    throw new Error(body.error || `/use ${r.status}`);
  }

  async function onStepClick(t, i) {
    if (!authState?.channelId || !getApiUserId()) {
      hintEl.textContent = "Noch nicht autorisiert";
      return;
    }

    if (pendingToggle) {
      hintEl.textContent = "Warte… oder klicke Abbrechen";
      return;
    }

    pendingToggle = { t, i };
    refreshClasses();

    try {
      const res = await consumeCredit();
      if (res.ok) {
        applyToggle(t, i);
        pendingToggle = null;
        refreshClasses();
        hintEl.textContent = `Step gesetzt ✅ (${credits} Credits übrig)`;
        return;
      }

      showBuyOptions(true);
      hintEl.textContent = "Keine Credits mehr. Bitte Credit-Paket kaufen.";
    } catch (e) {
      cancelPending();
      hintEl.textContent = `Fehler: ${String(e)}`;
    }
  }

  async function grantPurchasedCredits(sku) {
    const r = await fetch(`${EBS_BASE}/purchase`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ channelId: authState.channelId, userId: getApiUserId(), sku }),
    });
    const body = await r.json();
    if (!r.ok) {
      throw new Error(body.error || `/purchase ${r.status}`);
    }
    credits = Number(body.credits || 0);
    renderCredits();
  }

  function startPurchase(sku) {
    if (!pendingToggle) {
      hintEl.textContent = "Bitte zuerst einen Step klicken.";
      return;
    }
    if (!globalThis.Twitch?.ext?.bits?.useBits) {
      hintEl.textContent = "Bits API nicht verfügbar";
      return;
    }

    pendingPurchaseSku = sku;
    const pkg = CREDIT_SKUS[sku];
    hintEl.textContent = `Kaufdialog: ${pkg.bits} Bits für ${pkg.credits} Credits…`;
    Twitch.ext.bits.useBits(sku);
  }

  document.querySelectorAll(".buyBtn").forEach((btn) => {
    btn.addEventListener("click", () => startPurchase(btn.dataset.sku));
  });

  if (globalThis.Twitch?.ext?.bits?.onTransactionComplete) {
    Twitch.ext.bits.onTransactionComplete(async (tx) => {
      const sku = tx?.product?.sku;
      if (!sku || !CREDIT_SKUS[sku] || sku !== pendingPurchaseSku) {
        hintEl.textContent = "Transaktion ignoriert (anderes Produkt).";
        return;
      }

      try {
        await grantPurchasedCredits(sku);
        showBuyOptions(false);

        if (pendingToggle) {
          const { t, i } = pendingToggle;
          const useRes = await consumeCredit();
          if (useRes.ok) {
            applyToggle(t, i);
            pendingToggle = null;
            refreshClasses();
            hintEl.textContent = `Kauf OK ✅ + Step gesetzt (${credits} Credits übrig)`;
          } else {
            hintEl.textContent = "Credits gekauft, aber Step konnte nicht gesetzt werden.";
          }
        }
      } catch (e) {
        hintEl.textContent = `Fehler nach Kauf: ${String(e)}`;
      } finally {
        pendingPurchaseSku = null;
      }
    });
  }

  buildUIOnce();
  updateDebug();
  renderCredits();
  renderIdentity();
  refreshClasses();

  setInterval(() => {
    playStep = (playStep + 1) % STEPS;
    refreshClasses();
  }, stepMs);

  globalThis.addEventListener("DOMContentLoaded", () => {
    Twitch.ext.onAuthorized(async (auth) => {
      authState = auth;
      lastAuthSnapshot = {
        channelId: auth.channelId,
        clientId: auth.clientId,
        userId: auth.userId,
        role: auth.role,
        helixToken: auth.helixToken,
        token: auth.token,
      };
      updateIdentityFromTwitch();
      statusEl.textContent = `Overlay läuft ✅ (authorized) — channelId=${auth.channelId}`;

      await detectMode();
      await fetchIdentityFromHelix();
      renderIdentity();

      try {
        await fetchBalance();
        hintEl.textContent = "Klick auf Step kostet 1 Credit";
      } catch (e) {
        hintEl.textContent = `Konnte Credits nicht laden: ${String(e)}`;
      }
    });
  });
</script>
</body>
</html>
