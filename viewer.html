<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Step Grid</title>
  <style>
    html, body { width:100%; height:100%; margin:0; }
    body { background: rgba(0,0,0,0); font-family: system-ui, sans-serif; }
    .panel {
      position: absolute; top: 20px; left: 20px;
      background: rgba(0,0,0,0.65); color: #fff;
      padding: 12px; border-radius: 12px;
      width: 640px;
    }
    .hint { opacity: 0.85; font-size: 13px; margin-top: 4px; }
    .trackRow { display:flex; align-items:center; gap:10px; margin-top:10px; }
    .trackName { width: 70px; opacity: .9; font-size: 13px; }
    .grid { display:grid; grid-template-columns: repeat(16, 1fr); gap:6px; width: 100%; }
    .step {
      height: 22px; border-radius: 6px; cursor: pointer;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.18);
      user-select: none;
    }
    .step.on { background: rgba(0,255,120,0.55); border-color: rgba(0,255,120,0.9); }
    .step.play { outline: 2px solid rgba(255,255,255,0.9); }
    .step.pending { outline: 2px solid rgba(255,255,0,0.9); }
    .small { opacity: 0.75; font-size: 12px; margin-top: 10px; }
  </style>
</head>
<body>
<div class="panel">
  <div id="status">Overlay geladen…</div>
  <div class="hint" id="hint">Init…</div>
  <div id="tracks"></div>
  <div class="small" id="debug"></div>
</div>

<script src="https://extension-files.twitch.tv/helper/v1/twitch-ext.min.js"></script>
<script>
  const STEPS = 16;
  const trackNames = ["Kick", "Snare", "Hat", "Bass"];
  const state = trackNames.map(() => new Array(STEPS).fill(false));

  // ===== DEV SCHALTER =====
  const BITS_ENABLED = true; // <- für Entwicklung auf false setzen
  const BITS_SKU_STEP = "step_toggle_10";
  // ========================

  const tracksEl = document.getElementById("tracks");
  const statusEl = document.getElementById("status");
  const hintEl   = document.getElementById("hint");
  const debugEl  = document.getElementById("debug");

  // Playhead Timing
  let playStep = 0;
  const bpm = 90;
  const stepMs = (60_000 / bpm) / 4; // 16tel

  // Wir bauen DOM einmal und halten Referenzen
  const stepEls = trackNames.map(() => new Array(STEPS));

  // Bits: wir erlauben nur 1 offenen Kauf zur Zeit (sonst wird’s chaotisch)
  // {t, i}
  let pendingToggle = null;
  let purchaseInFlight = false;

  function patternStringForTrack(t) {
    return state[t].map(x => x ? "1" : "0").join("");
  }
  function updateDebug() {
    debugEl.textContent = trackNames.map((n,t)=> `${n}: ${patternStringForTrack(t)}`).join("   |   ");
  }

  function buildUIOnce() {
    tracksEl.innerHTML = "";
    for (let t = 0; t < trackNames.length; t++) {
      const row = document.createElement("div");
      row.className = "trackRow";

      const name = document.createElement("div");
      name.className = "trackName";
      name.textContent = trackNames[t];

      const grid = document.createElement("div");
      grid.className = "grid";

      for (let i = 0; i < STEPS; i++) {
        const b = document.createElement("div");
        b.className = "step";
        b.title = `${trackNames[t]} — Step ${i + 1}`;
        b.addEventListener("click", () => onStepClick(t, i));
        grid.appendChild(b);
        stepEls[t][i] = b;
      }

      row.appendChild(name);
      row.appendChild(grid);
      tracksEl.appendChild(row);
    }
  }

  function refreshClasses() {
    for (let t = 0; t < trackNames.length; t++) {
      for (let i = 0; i < STEPS; i++) {
        const el = stepEls[t][i];
        el.classList.toggle("on", state[t][i]);
        el.classList.toggle("play", i === playStep);
        el.classList.toggle("pending", pendingToggle && pendingToggle.t === t && pendingToggle.i === i);
      }
    }
  }

  function applyToggle(t, i) {
    state[t][i] = !state[t][i];
    refreshClasses();
    updateDebug();
  }

  function onStepClick(t, i) {
    if (!BITS_ENABLED) {
      hintEl.textContent = `DEV: toggled ${trackNames[t]} Step ${i+1}`;
      applyToggle(t, i);
      return;
    }

    // Bits-Mode
    if (purchaseInFlight) {
      hintEl.textContent = "Warte… (Bits-Kauf läuft bereits)";
      return;
    }

    // Bits API vorhanden?
    if (!globalThis.Twitch?.ext?.bits?.useBits) {
      hintEl.textContent = "Bits API nicht verfügbar (DEV?)";
      return;
    }

    purchaseInFlight = true;
    pendingToggle = { t, i };
    refreshClasses();
    hintEl.textContent = `Bits-Kauf: ${trackNames[t]} Step ${i+1}…`;

    Twitch.ext.bits.useBits(BITS_SKU_STEP);
  }

  // Bits callback: Kauf abgeschlossen
  if (globalThis.Twitch?.ext?.bits?.onTransactionComplete) {
    Twitch.ext.bits.onTransactionComplete((tx) => {
      console.log("bits tx complete", tx);
      purchaseInFlight = false;

      const sku = tx?.product?.sku;
      if (sku !== BITS_SKU_STEP) {
        hintEl.textContent = "Bits-Kauf abgeschlossen (anderes Produkt)";
        pendingToggle = null;
        refreshClasses();
        return;
      }

      if (pendingToggle) {
        applyToggle(pendingToggle.t, pendingToggle.i);
        hintEl.textContent = `Kauf OK ✅ ${trackNames[pendingToggle.t]} Step ${pendingToggle.i+1}`;
        pendingToggle = null;
        refreshClasses();
      }
    });
  }

  // Init
  buildUIOnce();
  updateDebug();
  hintEl.textContent = BITS_ENABLED ? "Bits-Modus aktiv (Klick → Kaufdialog)" : "DEV-Modus: Klick toggelt direkt";
  refreshClasses();

  // Playhead: nur Klassen updaten (kein DOM neu bauen)
  setInterval(() => {
    playStep = (playStep + 1) % STEPS;
    refreshClasses();
  }, stepMs);

  Twitch.ext.onAuthorized((auth) => {
    statusEl.textContent = `Overlay läuft ✅ (authorized) — channelId=${auth.channelId}`;
  });
</script>
</body>
</html>
